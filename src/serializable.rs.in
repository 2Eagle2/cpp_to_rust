use std::collections::{HashMap};

// ------------------------------
// from cpp_data

/// One item of a C++ enum declaration
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Serialize, Deserialize)]
pub struct EnumValue {
  /// Identifier
  pub name: String,
  /// Corresponding value
  pub value: i64,
}

/// Member field of a C++ class declaration
#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
pub struct CppClassField {
  /// Identifier
  pub name: String,
  /// Field type
  pub field_type: CppType,
  /// Visibility
  pub visibility: CppVisibility,
  /// Size of type in bytes
  pub size: Option<i32>,
}

/// Information about a C++ type declaration
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Serialize, Deserialize)]
pub enum CppTypeKind {
  /// Enum declaration
  Enum {
    /// List of items
    values: Vec<EnumValue>,
  },
  /// Class declaration
  Class {
    /// Size of type in bytes;
    /// can be None if the type doesn't have known size,
    /// e.g. it's a template class
    size: Option<i32>,
    /// List of class types this class is derived from
    bases: Vec<CppType>,
    /// List of class fields
    fields: Vec<CppClassField>,
    /// If the class is a template class, this field contains
    /// names of its template arguments. Names themselves are
    /// not particularly important, but their count is.
    /// If the class is not a template class, this field is None.
    template_arguments: Option<Vec<String>>,
  },
}

/// Location of a C++ type's definition in header files.
#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
pub struct CppOriginLocation {
  // Full path to the include file
  pub include_file_path: String,
  /// Line of the file
  pub line: u32,
  /// Column of the file
  pub column: u32,
}

/// Visibility of a C++ entity. Defaults to Public
/// for entities that can't have visibility (like free functions)
#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
pub enum CppVisibility {
  Public,
  Protected,
  Private,
}

/// Information about a C++ type declaration
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Serialize, Deserialize)]
pub struct CppTypeData {
  /// Identifier, including namespaces and nested classes
  /// (separated with "::", like in C++)
  pub name: String,
  /// File name of the include file (without full path)
  pub include_file: String,
  /// Exact location of the declaration
  pub origin_location: CppOriginLocation,
  /// Type information
  pub kind: CppTypeKind,
}

/// Information about a C++ template class
/// instantiation.
#[derive(Debug, PartialEq, Eq, Clone, Default)]
#[derive(Serialize, Deserialize)]
pub struct CppTemplateInstantiation {
  /// List of template arguments used in this instantiation
  pub template_arguments: Vec<CppType>,
  /// Size of resulted type in bytes
  pub size: i32,
}

/// C++ parser output
#[derive(Debug, PartialEq, Eq, Clone, Default)]
#[derive(Serialize, Deserialize)]
pub struct CppData {
  /// List of found type declarations
  pub types: Vec<CppTypeData>,
  /// List of found methods
  pub methods: Vec<CppMethod>,
  /// List of found template instantiations. Key is name of
  /// the template class, value is list of instantiations.
  pub template_instantiations: HashMap<String, Vec<CppTemplateInstantiation>>,
}

// -----------------------------------
// from cpp_method

/// Information about an argument of a C++ method
#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
pub struct CppFunctionArgument {
  /// Identifier. If the argument doesn't have a name
  /// (which is allowed in C++), this field contains
  /// generated name "argX" (X is position of the argument).
  pub name: String,
  /// Argument type
  pub argument_type: CppType,
  /// Flag indicating that the argument has default value and
  /// therefore can be omitted when calling the method
  pub has_default_value: bool,
}

/// Enumerator indicating special cases of C++ methods.
#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
pub enum CppMethodKind {
  /// Just a class method
  Regular,
  /// Constructor
  Constructor,
  /// Destructor
  Destructor,
}



#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
pub struct CppMethodClassMembership {
  /// Type of the class where this method belong. This is used to construct
  /// type of "this" pointer and return type of constructors.
  pub class_type: CppTypeClassBase,
  /// Whether this method is a constructor, a destructor or an operator
  pub kind: CppMethodKind,
  /// True if this is a virtual method
  pub is_virtual: bool,
  /// True if this is a pure virtual method (requires is_virtual = true)
  pub is_pure_virtual: bool,
  /// True if this is a const method, i.e. "this" pointer receives by
  /// this method has const type
  pub is_const: bool,
  /// True if this is a static method, i.e. it doesn't receive "this" pointer at all.
  pub is_static: bool,
  /// Method visibility
  pub visibility: CppVisibility,
  /// True if the method is a Qt signal
  pub is_signal: bool, //TODO: implement signal detection or remove this field
}

/// Information about a C++ method
#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
pub struct CppMethod {
  /// Identifier. For class methods, this field includes
  /// only the method's own name. For free functions,
  /// this field also includes namespaces (if any).
  pub name: String,
  /// Additional information about a class member function
  /// or None for free functions
  pub class_membership: Option<CppMethodClassMembership>,
  /// If the method is a C++ operator, indicates its kind
  pub operator: Option<CppOperator>,
  /// Return type of the method.
  /// Return type is reported as void for constructors and destructors.
  pub return_type: CppType,
  /// List of the method's arguments
  pub arguments: Vec<CppFunctionArgument>,

  pub arguments_before_omitting: Option<Vec<CppFunctionArgument>>,
  /// Whether the argument list is terminated with "..."
  pub allows_variadic_arguments: bool,
  /// File name of the include file where the method is defined
  /// (without full path)
  pub include_file: String,
  /// Exact location of declaration of the method.
  /// Can be None if the method is generated automatically
  /// and doesn't have corresponding C++ declaration.
  pub origin_location: Option<CppOriginLocation>,
  /// Names of the method's template arguments.
  /// None if this is not a template method.
  /// If the method belongs to a template class,
  /// the class's template arguments are not included here.
  pub template_arguments: Option<Vec<String>>,

  pub declaration_code: Option<String>,
}

// ------------------------------
// from cpp_operators

/// Available types of C++ operators
#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
pub enum CppOperator {
  /// (type) a
  Conversion(CppType),
  /// a = b
  Assignment,
  /// a + b
  Addition,
  /// a - b
  Subtraction,
  /// +a
  UnaryPlus,
  /// -a
  UnaryMinus,
  /// a * b
  Multiplication,
  /// a / b
  Division,
  /// a % b
  Modulo,
  /// ++a
  PrefixIncrement,
  /// a++
  PostfixIncrement,
  /// --a
  PrefixDecrement,
  /// a--
  PostfixDecrement,
  /// a == b
  EqualTo,
  /// a != b
  NotEqualTo,
  /// a > b
  GreaterThan,
  /// a < b
  LessThan,
  /// a >= b
  GreaterThanOrEqualTo,
  /// a <= b
  LessThanOrEqualTo,
  /// !a
  LogicalNot,
  /// a && b
  LogicalAnd,
  /// a || b
  LogicalOr,
  /// ~a
  BitwiseNot,
  /// a & b
  BitwiseAnd,
  /// a | b
  BitwiseOr,
  /// a ^ b
  BitwiseXor,
  /// a << b
  BitwiseLeftShift,
  /// a >> b
  BitwiseRightShift,

  /// a += b
  AdditionAssignment,
  /// a -= b
  SubtractionAssignment,
  /// a *= b
  MultiplicationAssignment,
  /// a /= b
  DivisionAssignment,
  /// a %= b
  ModuloAssignment,
  /// a &= b
  BitwiseAndAssignment,
  /// a |= b
  BitwiseOrAssignment,
  /// a ^= b
  BitwiseXorAssignment,
  /// a <<= b
  BitwiseLeftShiftAssignment,
  /// a >>= b
  BitwiseRightShiftAssignment,
  /// a[b]
  Subscript,
  /// *a
  Indirection,
  /// &a
  AddressOf,
  /// a->b
  StructureDereference,
  /// a->*b
  PointerToMember,
  /// a(a1, a2)
  FunctionCall,
  /// a, b
  Comma,
  /// new type
  New,
  /// new type[n]
  NewArray,
  /// delete a
  Delete,
  /// delete[] a
  DeleteArray,
}

// -------------------------------
// from cpp_type

/// C++ type variants based on indirection
#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
#[allow(dead_code)]
pub enum CppTypeIndirection {
  /// No indirection
  None,
  /// Pointer, like int*
  Ptr,
  /// Reference, like int&
  Ref,
  /// Reference to pointer, like int*&
  PtrRef,
  /// Pointer to pointer, like int**
  PtrPtr,
  /// R-value reference, like Class&&
  RValueRef,
}

/// Available built-in C++ numeric types.
/// All these types have corresponding
/// clang::TypeKind values (except for CharS and CharU
/// which map to CppBuiltInNumericType::Char)
#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
pub enum CppBuiltInNumericType {
  Bool,
  Char,
  SChar,
  UChar,
  WChar,
  Char16,
  Char32,
  Short,
  UShort,
  Int,
  UInt,
  Long,
  ULong,
  LongLong,
  ULongLong,
  Int128,
  UInt128,
  Float,
  Double,
  LongDouble,
}

/// Information about a fixed-size primitive type
#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
#[allow(dead_code)]
pub enum CppSpecificNumericTypeKind {
  Integer {
    is_signed: bool,
  },
  FloatingPoint,
}

/// Information about base C++ class type
#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
pub struct CppTypeClassBase {
  /// Name, including namespaces and nested classes
  pub name: String,
  /// For template classes, C++ types used as template
  /// arguments in this type,
  /// like [QString, int] in QHash<QString, int>
  pub template_arguments: Option<Vec<CppType>>,
}

/// Base C++ type. CppType can add indirection
/// and constness to CppTypeBase, but otherwise
/// this enum lists all supported types.
#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
pub enum CppTypeBase {
  /// Void
  Void,
  /// Built-in C++ primitive type, like int
  BuiltInNumeric(CppBuiltInNumericType),
  /// Fixed-size primitive type, like qint64 or int64_t
  /// (may be translated to Rust's i64)
  SpecificNumeric {
    /// Type identifier (most likely a typedef name)
    name: String,
    /// Size of type in bits
    bits: i32,
    /// Information about the type (float or integer,
    /// signed or unsigned)
    kind: CppSpecificNumericTypeKind,
  },
  /// Pointer sized integer, like qintptr
  /// (may be translated to Rust's isize)
  PointerSizedInteger {
    name: String,
    is_signed: bool,
  },
  /// Enum type
  Enum {
    /// Name, including namespaces and nested classes
    name: String,
  },
  /// Class type
  Class(CppTypeClassBase),
  /// Template parameter, like "T" anywhere inside
  /// QVector<T> declaration
  TemplateParameter {
    /// Template instantiation level. For example,
    /// if there is a template class and a template method in it,
    /// the class's template parameters will have level = 0 and
    /// the method's template parameters will have level = 1.
    /// If only the class or only the method is a template,
    /// the level will be 0.
    nested_level: i32,
    /// Index of the parameter. In QHash<K, V> "K" has index = 0
    /// and "V" has index = 1.
    index: i32,
  },
  /// Function pointer type
  FunctionPointer {
    /// Return type of the function
    return_type: Box<CppType>,
    /// Arguments of the function
    arguments: Vec<CppType>,
    /// Whether arguments are terminated with "..."
    allows_variadic_arguments: bool,
  },
}

/// Information about a C++ type
#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
pub struct CppType {
  /// Information about base type
  pub base: CppTypeBase,
  /// Indirection applied to base type
  pub indirection: CppTypeIndirection,
  /// If the type has const qualifier. Defaults to false
  /// when not applicable. Complex constness cases
  /// (like "const int * const") are not supported.
  pub is_const: bool,
}

// -------------------------
// from main

/// Information loaded from lib spec file and
/// related to the C++ side
#[derive(Debug, Clone)]
#[derive(Serialize, Deserialize)]
pub struct CppLibSpec {
  /// Name of C++ library used for linking
  pub name: String,
  /// Name of the library's include file
  pub include_file: String,
  /// List of C++ identifiers which should be skipped
  /// by C++ parser. Identifier can contain namespaces
  /// and nested classes, with "::" separator (like in
  /// C++ identifiers). Identifier may refer to a method,
  /// a class or a namespace. All entities inside blacklisted
  /// entity will also be skipped.
  pub name_blacklist: Vec<String>,
  pub include_file_blacklist: Vec<String>,

  pub ffi_methods_blacklist: Vec<String>,
}

/// Information loaded from lib spec file and
/// related to generated Rust crate
#[derive(Debug, Clone)]
#[derive(Serialize, Deserialize)]
pub struct RustLibSpec {
  // TODO: remove these fields and parse Cargo.toml instead
  /// Name of the crate
  pub name: String,
  /// Version of the crate
  pub version: String,
  /// Authors of the crate
  pub authors: Vec<String>,
  /// List of top level modules that should not be generated
  pub module_blacklist: Vec<String>,
}

/// Information loaded from lib spec file.
/// This struct contains general instructions
/// about processing the library.
#[derive(Debug, Clone)]
#[derive(Serialize, Deserialize)]
pub struct LibSpec {
  /// Information related to the C++ side
  pub cpp: CppLibSpec,
  /// Information related to generated Rust crate
  pub rust: RustLibSpec,
}
